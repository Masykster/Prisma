<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prisma - Color Palette Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #6366f1;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            color: #1f2937;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 2rem;
            overflow-x: hidden;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes spinOnce {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .animate-spin-once {
            animation: spinOnce 0.5s ease-out;
        }

        .glass-panel {
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.15);
        }

        .font-heading { font-family: 'Space Grotesk', sans-serif; }

        .tab-btn {
            font-family: 'Space Grotesk', sans-serif;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .tab-btn::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 50%;
            width: 0;
            height: 3px;
            background-color: var(--primary);
            transition: width 0.3s ease;
            transform: translateX(-50%);
        }

        .tab-btn.active::after { width: 100%; }

        /* Custom Scrollbar for saved section */
        .custom-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: #f1f1f1; 
            border-radius: 4px;
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background: #d1d5db; 
            border-radius: 4px;
        }
        .custom-scroll::-webkit-scrollbar-thumb:hover {
            background: #9ca3af; 
        }

        .palette-strip span {
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        /* Responsive Canvas */
        .canvas-wrapper {
            position: relative;
            width: 260px;
            height: 260px;
            border-radius: 50%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }
        .canvas-wrapper:hover { transform: scale(1.02); }

        /* Notification Toast */
        .toast {
            transform: translateY(150%);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s ease;
            opacity: 0;
        }
        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }
    </style>
</head>
<body class="antialiased selection:bg-indigo-500 selection:text-white">
    
    <div class="glass-panel w-full max-w-[1000px] rounded-[2rem] p-6 md:p-12 flex flex-col gap-8 animate-fade-in-up">
        
        <!-- Header -->
        <div class="flex flex-col items-center justify-center gap-2 text-center">
            <div class="flex items-center gap-3">
                <svg width="40" height="40" viewBox="0 0 40 40" fill="none" class="drop-shadow-sm">
                    <rect x="5" y="5" width="10" height="10" rx="3" fill="#6366F1"/>
                    <rect x="20" y="5" width="10" height="10" rx="3" fill="#EC4899"/>
                    <rect x="5" y="20" width="10" height="10" rx="3" fill="#14B8A6"/>
                    <rect x="20" y="20" width="10" height="10" rx="3" fill="#F59E0B"/>
                </svg>                
                <h1 class="text-4xl font-bold text-gray-900 tracking-tight font-heading">Prisma</h1>
            </div>
            <p class="text-gray-500 font-medium">Aesthetic Color Palette Generator</p>
        </div>
        
        <!-- Navigation -->
        <div class="flex justify-center border-b border-gray-200 w-full max-w-md mx-auto">
            <button class="tab-btn active px-8 py-3 text-indigo-600 font-semibold text-gray-400 hover:text-gray-600" data-tab="wheel">Color Wheel</button>
            <button class="tab-btn px-8 py-3 font-semibold text-gray-400 hover:text-gray-600" data-tab="image">From Image</button>
        </div>
        
        <!-- Main Content Area -->
        <div class="flex flex-col lg:flex-row items-start justify-center gap-10 lg:gap-16 py-4">
            
            <!-- Left: Inputs -->
            <div class="flex flex-col items-center justify-center w-full lg:w-auto relative min-h-[300px]">
                
                <!-- Wheel Mode -->
                <div id="view-wheel" class="flex flex-col items-center gap-6 transition-all duration-300">
                    <div class="canvas-wrapper">
                        <canvas id="color-wheel" width="260" height="260" class="cursor-crosshair rounded-full"></canvas>
                    </div>
                    
                    <div class="flex flex-col items-center bg-white px-6 py-3 rounded-2xl shadow-sm border border-gray-100 w-full max-w-[200px]">
                        <span class="text-[10px] text-gray-400 font-bold tracking-widest uppercase mb-1">Base Color</span>
                        <div class="flex items-center gap-3 w-full justify-center">
                            <div id="preview-dot" class="w-4 h-4 rounded-full bg-blue-500 shadow-sm border border-gray-100"></div>
                            <input type="text" id="hex-input" maxlength="7" class="font-mono font-bold text-xl text-gray-800 text-center focus:outline-none w-24 bg-transparent uppercase" value="#3498DB">
                        </div>
                    </div>
                </div>

                <!-- Image Mode -->
                <div id="view-image" class="hidden flex-col items-center gap-4 w-full">
                    <div id="drop-zone" class="w-[260px] h-[260px] border-2 border-dashed border-gray-300 rounded-[1.5rem] flex flex-col justify-center items-center cursor-pointer hover:border-indigo-500 hover:bg-indigo-50/50 transition-all duration-300 bg-gray-50/30 overflow-hidden relative group">
                        <input type="file" id="file-input" accept="image/*" class="hidden">
                        
                        <div id="upload-placeholder" class="text-center p-6 transition-opacity duration-300">
                            <div class="bg-indigo-100 w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4 text-indigo-600 group-hover:scale-110 transition-transform">
                                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                            </div>
                            <span class="text-gray-700 font-heading font-bold block">Upload Image</span>
                            <span class="text-xs text-gray-400 mt-1">JPG, PNG supported</span>
                        </div>
                        <img id="image-preview" class="hidden w-full h-full object-cover" alt="Preview">
                    </div>
                    <p class="text-xs text-gray-400 font-medium text-center max-w-[250px]">Extracts distinct aesthetic colors automatically.</p>
                </div>
            </div>
            
            <!-- Right: Controls -->
            <div class="flex flex-col gap-6 w-full lg:w-[350px]">
                
                <div id="harmony-wrapper" class="flex flex-col gap-2 w-full transition-opacity duration-300">
                    <label class="text-xs font-bold text-gray-400 uppercase tracking-widest pl-1">Harmony Rule</label>
                    <div class="relative">
                        <select id="harmony-select" class="w-full appearance-none bg-gray-50 border border-gray-200 text-gray-700 py-3.5 px-4 rounded-xl font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500/20 focus:border-indigo-500 transition-all cursor-pointer">
                            <option value="monochromatic">Monochromatic</option>
                            <option value="analogous">Analogous</option>
                            <option value="complementary">Complementary</option>
                            <option value="triadic">Triadic</option>
                            <option value="split-complementary">Split Complementary</option>
                            <option value="tetradic">Tetradic</option>
                            <option value="square">Square</option>
                        </select>
                        <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-4 text-gray-500">
                            <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </div>
                    </div>
                </div>

                <div class="flex gap-4 w-full">
                    <button id="btn-random" class="flex-1 bg-indigo-50 text-indigo-600 hover:bg-indigo-100 py-3.5 rounded-xl font-bold font-heading flex items-center justify-center gap-2 transition-all active:scale-95">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"/><path d="M1 20v-6h6"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>
                        Randomize
                    </button>
                    <button id="btn-save" class="flex-1 bg-gray-900 text-white hover:bg-black py-3.5 rounded-xl font-bold font-heading flex items-center justify-center gap-2 transition-all shadow-lg hover:shadow-xl active:scale-95">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>
                        Save
                    </button>
                </div>
            </div>
        </div>

        <!-- Palette Preview -->
        <div class="mt-2">
            <h2 id="palette-title" class="text-2xl font-bold text-gray-800 mb-6 flex items-center gap-3 font-heading">
                <span class="w-2 h-8 rounded-full bg-indigo-500 block"></span>
                Current Palette
            </h2>
            <div id="current-palette" class="w-full"></div>
        </div>

        <!-- Saved Palettes -->
        <div id="saved-section" class="hidden mt-8 pt-8 border-t border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-8 flex items-center gap-3 font-heading">
                <span class="w-2 h-8 rounded-full bg-emerald-500 block"></span>
                Collection
            </h2>
            <div id="saved-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8"></div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast fixed bottom-8 right-8 bg-gray-900/95 backdrop-blur-sm text-white px-6 py-4 rounded-2xl shadow-2xl flex items-center gap-3 z-50 font-medium border border-gray-700/50">
        <div class="bg-emerald-500 rounded-full p-1">
            <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"></path></svg>
        </div>
        <span id="toast-msg">Action successful</span>
    </div>

    <script>
        /**
         * Color Palette Generator App
         * Encapsulated logic to prevent global scope pollution
         */
        class ColorPaletteApp {
            constructor() {
                // State
                this.state = {
                    mode: 'wheel', // 'wheel' | 'image'
                    hue: 210,
                    saturation: 100,
                    lightness: 54,
                    colors: [],
                    isDragging: false
                };

                // Constants
                this.CONFIG = {
                    width: 260,
                    height: 260,
                    imgScale: 150
                };

                // DOM Elements
                this.dom = {
                    tabs: document.querySelectorAll('.tab-btn'),
                    views: {
                        wheel: document.getElementById('view-wheel'),
                        image: document.getElementById('view-image')
                    },
                    canvas: document.getElementById('color-wheel'),
                    hexInput: document.getElementById('hex-input'),
                    previewDot: document.getElementById('preview-dot'),
                    harmonySelect: document.getElementById('harmony-select'),
                    harmonyWrapper: document.getElementById('harmony-wrapper'),
                    btnRandom: document.getElementById('btn-random'),
                    btnSave: document.getElementById('btn-save'),
                    paletteContainer: document.getElementById('current-palette'),
                    paletteTitle: document.getElementById('palette-title'),
                    savedSection: document.getElementById('saved-section'),
                    savedGrid: document.getElementById('saved-grid'),
                    toast: document.getElementById('toast'),
                    toastMsg: document.getElementById('toast-msg'),
                    dropZone: document.getElementById('drop-zone'),
                    fileInput: document.getElementById('file-input'),
                    imagePreview: document.getElementById('image-preview'),
                    uploadPlaceholder: document.getElementById('upload-placeholder')
                };

                this.ctx = this.dom.canvas.getContext('2d');
                // Offscreen canvas for better performance (caching the wheel)
                this.wheelCache = document.createElement('canvas');
                this.wheelCache.width = this.CONFIG.width;
                this.wheelCache.height = this.CONFIG.height;
                
                this.init();
            }

            init() {
                this.preRenderColorWheel();
                this.draw();
                this.bindEvents();
                this.updatePalette();
                this.loadSavedPalettes();
            }

            // --- Graphics Logic ---

            preRenderColorWheel() {
                const ctx = this.wheelCache.getContext('2d');
                const { width, height } = this.CONFIG;
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(centerX, centerY) - 10;

                ctx.clearRect(0, 0, width, height);

                // Draw hue segments
                for (let i = 0; i < 360; i++) {
                    const angle = i * Math.PI / 180;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, angle, (i + 1.5) * Math.PI / 180);
                    ctx.closePath();
                    ctx.fillStyle = `hsl(${i}, 100%, 50%)`;
                    ctx.fill();
                }

                // White radial gradient (Saturation/Lightness approximation)
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, 'white');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fill();
            }

            draw() {
                // Clear and draw cached wheel
                this.ctx.clearRect(0, 0, this.CONFIG.width, this.CONFIG.height);
                this.ctx.drawImage(this.wheelCache, 0, 0);

                // Draw Cursor
                const { width, height } = this.CONFIG;
                const radius = Math.min(width, height) / 2 - 10;
                const angleRad = this.state.hue * (Math.PI / 180);
                const dist = (this.state.saturation / 100) * radius;
                
                const x = (width / 2) + dist * Math.cos(angleRad);
                const y = (height / 2) + dist * Math.sin(angleRad);

                // Cursor styling
                this.ctx.beginPath();
                this.ctx.arc(x, y, 8, 0, 2 * Math.PI);
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                this.ctx.fill();

                this.ctx.beginPath();
                this.ctx.arc(x, y, 6, 0, 2 * Math.PI);
                this.ctx.strokeStyle = 'white'; 
                this.ctx.lineWidth = 2.5;
                this.ctx.stroke(); 

                this.ctx.beginPath();
                this.ctx.arc(x, y, 4.5, 0, 2 * Math.PI);
                this.ctx.fillStyle = this.hslToHex(this.state.hue, this.state.saturation, this.state.lightness);
                this.ctx.fill();
            }

            // --- Event Handling ---

            bindEvents() {
                // Tab Switching
                this.dom.tabs.forEach(btn => {
                    btn.addEventListener('click', (e) => this.switchTab(e.target.dataset.tab));
                });

                // Canvas Interaction (Mouse & Touch)
                const handleStart = () => this.state.isDragging = true;
                const handleEnd = () => this.state.isDragging = false;
                const handleMove = (e) => {
                    if (!this.state.isDragging || this.state.mode !== 'wheel') return;
                    e.preventDefault(); // Prevent scroll on touch
                    
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const rect = this.dom.canvas.getBoundingClientRect();
                    
                    this.updateColorFromCoords(clientX - rect.left, clientY - rect.top);
                };

                this.dom.canvas.addEventListener('mousedown', handleStart);
                this.dom.canvas.addEventListener('touchstart', handleStart, { passive: false });
                
                window.addEventListener('mouseup', handleEnd);
                window.addEventListener('touchend', handleEnd);
                
                this.dom.canvas.addEventListener('mousemove', (e) => requestAnimationFrame(() => handleMove(e)));
                this.dom.canvas.addEventListener('touchmove', (e) => requestAnimationFrame(() => handleMove(e)), { passive: false });

                // Hex Input
                this.dom.hexInput.addEventListener('input', (e) => {
                    let val = e.target.value;
                    if (!val.startsWith('#')) val = '#' + val;
                    if (/^#[0-9A-F]{6}$/i.test(val)) {
                        const [h, s, l] = this.hexToHsl(val);
                        this.state.hue = h;
                        this.state.saturation = s;
                        this.state.lightness = l;
                        this.draw();
                        this.updatePalette();
                    }
                });

                // Controls
                this.dom.harmonySelect.addEventListener('change', () => this.updatePalette());
                
                this.dom.btnRandom.addEventListener('click', () => {
                    this.state.hue = Math.floor(Math.random() * 360);
                    this.state.saturation = 60 + Math.random() * 40;
                    this.state.lightness = 40 + Math.random() * 30;
                    
                    this.dom.btnRandom.classList.add('animate-spin-once');
                    setTimeout(() => this.dom.btnRandom.classList.remove('animate-spin-once'), 500);
                    
                    this.updateUIFromState();
                });

                this.dom.btnSave.addEventListener('click', () => this.saveCurrentPalette());

                // Image Upload
                this.dom.dropZone.addEventListener('click', () => this.dom.fileInput.click());
                this.dom.fileInput.addEventListener('change', (e) => {
                    if (e.target.files[0]) this.processImage(e.target.files[0]);
                });
                
                // Drag & Drop
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    this.dom.dropZone.addEventListener(eventName, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });
                
                this.dom.dropZone.addEventListener('dragover', () => {
                    this.dom.dropZone.classList.add('border-indigo-500', 'bg-indigo-50');
                });
                
                this.dom.dropZone.addEventListener('dragleave', () => {
                    this.dom.dropZone.classList.remove('border-indigo-500', 'bg-indigo-50');
                });

                this.dom.dropZone.addEventListener('drop', (e) => {
                    this.dom.dropZone.classList.remove('border-indigo-500', 'bg-indigo-50');
                    if (e.dataTransfer.files[0]) this.processImage(e.dataTransfer.files[0]);
                });
            }

            // --- Logic Methods ---

            switchTab(tabName) {
                this.state.mode = tabName;
                
                // UI Toggle
                this.dom.tabs.forEach(t => t.classList.toggle('active', t.dataset.tab === tabName));
                this.dom.tabs.forEach(t => t.classList.toggle('text-indigo-600', t.dataset.tab === tabName));
                
                if (tabName === 'wheel') {
                    this.dom.views.wheel.classList.remove('hidden');
                    this.dom.views.image.classList.add('hidden');
                    this.dom.views.image.classList.remove('flex');
                    this.dom.harmonyWrapper.style.opacity = '1';
                    this.dom.harmonyWrapper.style.pointerEvents = 'auto';
                    this.dom.btnRandom.style.display = 'flex';
                    this.updatePalette();
                } else {
                    this.dom.views.wheel.classList.add('hidden');
                    this.dom.views.image.classList.remove('hidden');
                    this.dom.views.image.classList.add('flex');
                    this.dom.harmonyWrapper.style.opacity = '0.3';
                    this.dom.harmonyWrapper.style.pointerEvents = 'none';
                    this.dom.btnRandom.style.display = 'none';
                    
                    // Trigger extraction if image exists
                    if (!this.dom.imagePreview.classList.contains('hidden')) {
                         this.extractColors(this.dom.imagePreview);
                    } else {
                        this.dom.paletteContainer.innerHTML = `
                            <div class="p-8 text-center text-gray-400 border-2 border-dashed border-gray-200 rounded-2xl bg-gray-50/50">
                                Upload an image to start
                            </div>`;
                    }
                }
            }

            updateColorFromCoords(x, y) {
                const { width, height } = this.CONFIG;
                const centerX = width / 2;
                const centerY = height / 2;
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const radius = Math.min(centerX, centerY) - 10;

                if (distance <= radius) {
                    this.state.hue = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
                    this.state.saturation = Math.min(100, (distance / radius) * 100);
                    this.state.lightness = 50 + (1 - (distance / radius)) * 40;
                    this.updateUIFromState();
                }
            }

            updateUIFromState() {
                const hex = this.hslToHex(this.state.hue, this.state.saturation, this.state.lightness);
                this.dom.hexInput.value = hex;
                this.dom.previewDot.style.backgroundColor = hex;
                this.draw();
                this.updatePalette();
            }

            processImage(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    this.dom.imagePreview.src = e.target.result;
                    this.dom.imagePreview.classList.remove('hidden');
                    this.dom.uploadPlaceholder.classList.add('hidden');
                    // Wait for image load
                    this.dom.imagePreview.onload = () => this.extractColors(this.dom.imagePreview);
                };
                reader.readAsDataURL(file);
            }

            extractColors(img) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const scale = Math.min(this.CONFIG.imgScale / img.naturalWidth, this.CONFIG.imgScale / img.naturalHeight);
                canvas.width = img.naturalWidth * scale;
                canvas.height = img.naturalHeight * scale;
                
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                
                const colorMap = {};
                const QUANTIZATION = 20;

                for (let i = 0; i < data.length; i += 4) {
                    if (data[i+3] < 128) continue; // Skip transparent
                    const r = Math.round(data[i] / QUANTIZATION) * QUANTIZATION;
                    const g = Math.round(data[i+1] / QUANTIZATION) * QUANTIZATION;
                    const b = Math.round(data[i+2] / QUANTIZATION) * QUANTIZATION;
                    const key = `${r},${g},${b}`;
                    colorMap[key] = (colorMap[key] || 0) + 1;
                }

                // Sort by frequency and filter distinct
                const sorted = Object.keys(colorMap).sort((a,b) => colorMap[b] - colorMap[a]);
                const distinct = [];
                const MIN_DIST = 50;

                for (const rgbStr of sorted) {
                    if (distinct.length >= 5) break;
                    const [r,g,b] = rgbStr.split(',').map(Number);
                    
                    const isDistinct = distinct.every(c => {
                        return Math.sqrt(Math.pow(c.r-r,2) + Math.pow(c.g-g,2) + Math.pow(c.b-b,2)) > MIN_DIST;
                    });

                    if (isDistinct || distinct.length === 0) distinct.push({r,g,b});
                }
                
                // Fallback fill
                while(distinct.length < 5 && sorted.length > distinct.length) {
                     const [r,g,b] = sorted[distinct.length].split(',').map(Number);
                     distinct.push({r,g,b});
                }

                const hexColors = distinct.map(c => this.rgbToHex(c.r, c.g, c.b));
                this.state.colors = hexColors;
                
                this.dom.paletteTitle.innerHTML = `<span class="w-2 h-8 rounded-full bg-indigo-500 block"></span> Extracted from Image`;
                this.renderPaletteCard(hexColors, "Extracted", this.dom.paletteContainer);
            }

            updatePalette() {
                if (this.state.mode !== 'wheel') return;

                const { hue, saturation, lightness } = this.state;
                const type = this.dom.harmonySelect.value;
                const generator = this.generators[type];
                
                if (generator) {
                    this.state.colors = generator(hue, saturation, lightness, this.hslToHex.bind(this));
                    this.dom.paletteTitle.innerHTML = `<span class="w-2 h-8 rounded-full bg-indigo-500 block"></span> ${type.charAt(0).toUpperCase() + type.slice(1)}`;
                    this.renderPaletteCard(this.state.colors, type, this.dom.paletteContainer);
                }
            }

            // --- UI Rendering ---

            renderPaletteCard(colors, title, container, isSaved = false) {
                const card = document.createElement('div');
                card.className = `rounded-[1.5rem] overflow-hidden bg-white flex flex-col transition-all duration-300 ${isSaved ? 'h-[180px] border border-gray-100 shadow-sm hover:shadow-lg hover:-translate-y-1' : 'h-[160px]'}`;

                // Colors Area
                const display = document.createElement('div');
                display.className = isSaved ? 'h-[85%] flex w-full' : 'h-full flex w-full';
                
                colors.forEach(color => {
                    const strip = document.createElement('div');
                    strip.className = 'flex-1 flex items-center justify-center cursor-pointer transition-[flex] duration-300 ease-out hover:flex-[2.5] group relative';
                    strip.style.backgroundColor = color;
                    
                    // Accessibility Contrast Check
                    const textColor = this.getContrastColor(color);

                    const text = document.createElement('span');
                    text.textContent = color.replace('#', '');
                    text.className = `font-bold opacity-0 translate-y-2 group-hover:opacity-100 group-hover:translate-y-0 transition-all duration-300 text-sm tracking-wider pointer-events-none`;
                    text.style.color = textColor;

                    strip.appendChild(text);
                    strip.addEventListener('click', () => this.copyToClipboard(color));
                    display.appendChild(strip);
                });
                
                card.appendChild(display);

                // Footer (Only for saved)
                if (isSaved) {
                    const footer = document.createElement('div');
                    footer.className = 'h-[15%] flex items-center justify-between px-4 bg-white text-xs font-semibold text-gray-500 border-t border-gray-50';
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = title.split('•')[0]; // Simplify name
                    
                    const delBtn = document.createElement('button');
                    delBtn.innerHTML = `<svg class="w-4 h-4 text-gray-300 hover:text-red-500 transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>`;
                    delBtn.onclick = (e) => {
                        e.stopPropagation();
                        this.deletePalette(title);
                    };

                    footer.appendChild(nameSpan);
                    footer.appendChild(delBtn);
                    card.appendChild(footer);
                }

                container.innerHTML = '';
                if(isSaved) container.appendChild(card); // For grid, append works differently outside
                else container.appendChild(card); // For single view
                return card; // Return element for grid appending
            }

            // --- Generators & Helpers ---

            generators = {
                monochromatic: (h, s, l, toHex) => [
                    toHex(h, s, Math.max(10, l - 30)),
                    toHex(h, s, Math.max(15, l - 15)),
                    toHex(h, s, l),
                    toHex(h, s, Math.min(90, l + 15)),
                    toHex(h, s, Math.min(95, l + 30))
                ],
                analogous: (h, s, l, toHex) => [
                    toHex((h - 30 + 360) % 360, s, l),
                    toHex(h, s, l),
                    toHex((h + 30) % 360, s, l)
                ],
                complementary: (h, s, l, toHex) => [
                    toHex(h, s, l),
                    toHex((h + 180) % 360, s, l)
                ],
                triadic: (h, s, l, toHex) => [
                    toHex(h, s, l),
                    toHex((h + 120) % 360, s, l),
                    toHex((h + 240) % 360, s, l)
                ],
                'split-complementary': (h, s, l, toHex) => [
                    toHex(h, s, l),
                    toHex((h + 150) % 360, s, l),
                    toHex((h + 210) % 360, s, l)
                ],
                tetradic: (h, s, l, toHex) => [
                    toHex(h, s, l),
                    toHex((h + 60) % 360, s, l),
                    toHex((h + 180) % 360, s, l),
                    toHex((h + 240) % 360, s, l)
                ],
                square: (h, s, l, toHex) => [
                    toHex(h, s, l),
                    toHex((h + 90) % 360, s, l),
                    toHex((h + 180) % 360, s, l),
                    toHex((h + 270) % 360, s, l)
                ]
            };

            // Calculate luminance to decide text color (Black or White)
            getContrastColor(hex) {
                const r = parseInt(hex.substr(1, 2), 16);
                const g = parseInt(hex.substr(3, 2), 16);
                const b = parseInt(hex.substr(5, 2), 16);
                const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
                return (yiq >= 128) ? '#1f2937' : '#ffffff';
            }

            hslToHex(h, s, l) {
                l /= 100;
                const a = s * Math.min(l, 1 - l) / 100;
                const f = n => {
                    const k = (n + h / 30) % 12;
                    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                    return Math.round(255 * color).toString(16).padStart(2, '0');
                };
                return `#${f(0)}${f(8)}${f(4)}`.toUpperCase();
            }

            hexToHsl(H) {
                let r = 0, g = 0, b = 0;
                if (H.length == 4) {
                    r = "0x" + H[1] + H[1];
                    g = "0x" + H[2] + H[2];
                    b = "0x" + H[3] + H[3];
                } else if (H.length == 7) {
                    r = "0x" + H[1] + H[2];
                    g = "0x" + H[3] + H[4];
                    b = "0x" + H[5] + H[6];
                }
                r /= 255; g /= 255; b /= 255;
                let cmin = Math.min(r,g,b), cmax = Math.max(r,g,b), delta = cmax - cmin;
                let h = 0, s = 0, l = 0;

                if (delta == 0) h = 0;
                else if (cmax == r) h = ((g - b) / delta) % 6;
                else if (cmax == g) h = (b - r) / delta + 2;
                else h = (r - g) / delta + 4;

                h = Math.round(h * 60);
                if (h < 0) h += 360;
                l = (cmax + cmin) / 2;
                s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
                
                return [h, +(s * 100).toFixed(1), +(l * 100).toFixed(1)];
            }

            rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
            }

            async copyToClipboard(text) {
                try {
                    await navigator.clipboard.writeText(text);
                    this.showToast(`${text} Copied!`);
                } catch (err) {
                    // Fallback
                    const textArea = document.createElement("textarea");
                    textArea.value = text;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand("copy");
                    document.body.removeChild(textArea);
                    this.showToast(`${text} Copied!`);
                }
            }

            showToast(msg) {
                this.dom.toastMsg.textContent = msg;
                this.dom.toast.classList.add('show');
                setTimeout(() => this.dom.toast.classList.remove('show'), 2000);
            }

            // --- Storage ---

            saveCurrentPalette() {
                if (!this.state.colors.length) return;
                
                const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                const prefix = this.state.mode === 'image' ? 'Image' : this.dom.harmonySelect.value;
                // Capitalize
                const title = `${prefix.charAt(0).toUpperCase() + prefix.slice(1)} • ${time}`;
                
                const saved = JSON.parse(localStorage.getItem('pr_palettes') || '[]');
                saved.push({ name: title, colors: this.state.colors });
                localStorage.setItem('pr_palettes', JSON.stringify(saved));
                
                this.loadSavedPalettes();
                this.showToast('Collection Saved!');
            }

            loadSavedPalettes() {
                const saved = JSON.parse(localStorage.getItem('pr_palettes') || '[]');
                this.dom.savedGrid.innerHTML = '';
                
                if (saved.length > 0) {
                    this.dom.savedSection.classList.remove('hidden');
                    // Show newest first
                    saved.slice().reverse().forEach(p => {
                        const card = this.renderPaletteCard(p.colors, p.name, document.createElement('div'), true);
                        this.dom.savedGrid.appendChild(card);
                    });
                } else {
                    this.dom.savedSection.classList.add('hidden');
                }
            }

            deletePalette(name) {
                let saved = JSON.parse(localStorage.getItem('pr_palettes') || '[]');
                saved = saved.filter(p => p.name !== name);
                localStorage.setItem('pr_palettes', JSON.stringify(saved));
                this.loadSavedPalettes();
                this.showToast('Palette Removed');
            }
        }

        // Initialize App
        window.addEventListener('DOMContentLoaded', () => {
            new ColorPaletteApp();
        });

    </script>
</body>
</html>


